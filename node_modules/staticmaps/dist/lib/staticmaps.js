'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _sinh = require('babel-runtime/core-js/math/sinh');

var _sinh2 = _interopRequireDefault(_sinh);

var _requestPromise = require('request-promise');

var _requestPromise2 = _interopRequireDefault(_requestPromise);

var _gm = require('gm');

var _gm2 = _interopRequireDefault(_gm);

var _jimp = require('jimp');

var _jimp2 = _interopRequireDefault(_jimp);

var _lodash = require('lodash');

var _image = require('./image');

var _image2 = _interopRequireDefault(_image);

var _marker = require('./marker');

var _marker2 = _interopRequireDefault(_marker);

var _polyline = require('./polyline');

var _polyline2 = _interopRequireDefault(_polyline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* transform longitude to tile number */
var lonToX = function lonToX(lon, zoom) {
  return (lon + 180) / 360 * Math.pow(2, zoom);
};
/* transform latitude to tile number */
var latToY = function latToY(lat, zoom) {
  return (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom);
};

var yToLat = function yToLat(y, zoom) {
  return Math.atan((0, _sinh2.default)(Math.PI * (1 - 2 * y / Math.pow(2, zoom)))) / Math.PI * 180;
};

var xToLon = function xToLon(x, zoom) {
  return x / Math.pow(2, zoom) * 360 - 180;
};

var StaticMaps = function () {
  function StaticMaps() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, StaticMaps);

    this.gm = _gm2.default;
    this.options = options;

    this.width = this.options.width;
    this.height = this.options.height;
    this.paddingX = this.options.paddingX || 0;
    this.paddingY = this.options.paddingY || 0;
    this.padding = [this.paddingX, this.paddingY];
    this.tileUrl = this.options.tileUrl || 'http://tile.openstreetmap.org/{z}/{x}/{y}.png';
    this.tileSize = this.options.tileSize || 256;
    this.tileRequestTimeout = this.options.tileRequestTimeout;
    this.reverseY = this.options.reverseY || false;

    // # features
    this.markers = [];
    this.lines = [];
    this.polygons = [];

    // # fields that get set when map is rendered
    this.center = [];
    this.centerX = 0;
    this.centerY = 0;
    this.zoom = 0;
    if (this.options.imageMagick && _gm2.default.subClass) {
      this.gm = this.gm.subClass({ imageMagick: true });
    }
  }

  (0, _createClass3.default)(StaticMaps, [{
    key: 'addLine',
    value: function addLine(options) {
      this.lines.push(new _polyline2.default(options));
    }
  }, {
    key: 'addMarker',
    value: function addMarker(options) {
      this.markers.push(new _marker2.default(options));
    }
  }, {
    key: 'addPolygon',
    value: function addPolygon(options) {
      this.lines.push(new _polyline2.default(options));
    }

    /**
      * Render static map with all map features that were added to map before
      */

  }, {
    key: 'render',
    value: function render(center, zoom) {
      if (!this.lines && !this.markers && !this.polygons && !(center && zoom)) {
        throw new Error('Cannot render empty map: Add  center || lines || markers || polygons.');
      }

      this.center = center;
      this.zoom = zoom || this.calculateZoom();

      if (center && center.length === 2) {
        this.centerX = lonToX(center[0], this.zoom);
        this.centerY = latToY(center[1], this.zoom);
      } else {
        // # get extent of all lines
        var extent = this.determineExtent(this.zoom);

        // # calculate center point of map
        var centerLon = (extent[0] + extent[2]) / 2;
        var centerLat = (extent[1] + extent[3]) / 2;

        this.centerX = lonToX(centerLon, this.zoom);
        this.centerY = latToY(centerLat, this.zoom);
      }

      this.image = new _image2.default(this.options);

      return this.drawBaselayer().then(this.drawFeatures.bind(this));
    }

    /**
      * calculate common extent of all current map features
      */

  }, {
    key: 'determineExtent',
    value: function determineExtent(zoom) {
      var extents = [];

      // Add bbox to extent
      if (this.center && this.center.length >= 4) extents.push(this.center);

      // Add polylines and polygons to extent
      if (this.lines.length) {
        this.lines.forEach(function (line) {
          extents.push(line.extent());
        });
      } // extents.push(this.lines.map(function(line){ return line.extent(); }));

      // Add marker to extent
      for (var i = 0; i < this.markers.length; i++) {
        var marker = this.markers[i];
        var e = [marker.coord[0], marker.coord[1]];

        if (!zoom) {
          extents.push([marker.coord[0], marker.coord[1], marker.coord[0], marker.coord[1]]);
          continue;
        }

        // # consider dimension of marker
        var ePx = marker.extentPx();
        var x = lonToX(e[0], zoom);
        var y = latToY(e[1], zoom);

        extents.push([xToLon(x - parseFloat(ePx[0]) / this.tileSize, zoom), yToLat(y + parseFloat(ePx[1]) / this.tileSize, zoom), xToLon(x + parseFloat(ePx[2]) / this.tileSize, zoom), yToLat(y - parseFloat(ePx[3]) / this.tileSize, zoom)]);
      }

      // Add polygons to extent
      // if (this.polygons.length) extents.push(this.polygons.map(polygon => polygon.extent));

      return [extents.map(function (e) {
        return e[0];
      }).min(), extents.map(function (e) {
        return e[1];
      }).min(), extents.map(function (e) {
        return e[2];
      }).max(), extents.map(function (e) {
        return e[3];
      }).max()];
    }

    /**
      * calculate the best zoom level for given extent
      */

  }, {
    key: 'calculateZoom',
    value: function calculateZoom() {
      for (var z = 17; z > 0; z--) {
        var extent = this.determineExtent(z);
        var width = (lonToX(extent[2], z) - lonToX(extent[0], z)) * this.tileSize;
        if (width > this.width - this.padding[0] * 2) continue;

        var height = (latToY(extent[1], z) - latToY(extent[3], z)) * this.tileSize;
        if (height > this.height - this.padding[1] * 2) continue;

        return z;
      }
      return null;
    }

    /**
      * transform tile number to pixel on image canvas
      */

  }, {
    key: 'xToPx',
    value: function xToPx(x) {
      var px = (x - this.centerX) * this.tileSize + this.width / 2;
      return Number(Math.round(px));
    }

    /**
      * transform tile number to pixel on image canvas
      */

  }, {
    key: 'yToPx',
    value: function yToPx(y) {
      var px = (y - this.centerY) * this.tileSize + this.height / 2;
      return Number(Math.round(px));
    }
  }, {
    key: 'drawBaselayer',
    value: function drawBaselayer() {
      var _this = this;

      var xMin = Math.floor(this.centerX - 0.5 * this.width / this.tileSize);
      var yMin = Math.floor(this.centerY - 0.5 * this.height / this.tileSize);
      var xMax = Math.ceil(this.centerX + 0.5 * this.width / this.tileSize);
      var yMax = Math.ceil(this.centerY + 0.5 * this.height / this.tileSize);

      var result = [];

      for (var x = xMin; x < xMax; x++) {
        for (var y = yMin; y < yMax; y++) {
          // # x and y may have crossed the date line
          var maxTile = Math.pow(2, this.zoom);
          var tileX = (x + maxTile) % maxTile;
          var tileY = (y + maxTile) % maxTile;
          if (this.reverseY) tileY = (1 << this.zoom) - tileY - 1;

          result.push({
            url: this.tileUrl.replace('{z}', this.zoom).replace('{x}', tileX).replace('{y}', tileY),
            box: [this.xToPx(x), this.yToPx(y), this.xToPx(x + 1), this.yToPx(y + 1)]
          });
        }
      }

      var tilePromises = [];

      result.forEach(function (r) {
        tilePromises.push(_this.getTile(r));
      });

      return new _promise2.default(function (resolve, reject) {
        _promise2.default.all(tilePromises).then(function (tiles) {
          return _this.image.draw(tiles);
        }).then(resolve).catch(reject);
      });
    }
  }, {
    key: 'drawFeatures',
    value: function drawFeatures() {
      return this.drawLines().then(this.loadMarker.bind(this)).then(this.drawMarker.bind(this));
    }
  }, {
    key: 'drawLines',
    value: function drawLines() {
      var _this2 = this;

      return new _promise2.default(function () {
        var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(resolve) {
          var chunkedLines, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunkedLine;

          return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!_this2.lines.length) resolve(true);

                  // Due to gm limitations, we need to chunk coordinates
                  chunkedLines = [];

                  _this2.lines.forEach(function (line) {
                    var coords = _lodash._.chunk(line.coords, 120);
                    coords.forEach(function (c) {
                      var chunkedLine = _lodash._.clone(line);
                      chunkedLine.coords = c;
                      chunkedLines.push(chunkedLine);
                    });
                  });
                  // eslint-disable-next-line no-restricted-syntax
                  _iteratorNormalCompletion = true;
                  _didIteratorError = false;
                  _iteratorError = undefined;
                  _context.prev = 6;
                  _iterator = (0, _getIterator3.default)(chunkedLines);

                case 8:
                  if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    _context.next = 15;
                    break;
                  }

                  chunkedLine = _step.value;
                  _context.next = 12;
                  return _this2.draw(chunkedLine);

                case 12:
                  _iteratorNormalCompletion = true;
                  _context.next = 8;
                  break;

                case 15:
                  _context.next = 21;
                  break;

                case 17:
                  _context.prev = 17;
                  _context.t0 = _context['catch'](6);
                  _didIteratorError = true;
                  _iteratorError = _context.t0;

                case 21:
                  _context.prev = 21;
                  _context.prev = 22;

                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }

                case 24:
                  _context.prev = 24;

                  if (!_didIteratorError) {
                    _context.next = 27;
                    break;
                  }

                  throw _iteratorError;

                case 27:
                  return _context.finish(24);

                case 28:
                  return _context.finish(21);

                case 29:
                  resolve(true);

                case 30:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, _this2, [[6, 17, 21, 29], [22,, 24, 28]]);
        }));

        return function (_x2) {
          return _ref.apply(this, arguments);
        };
      }());
    }

    /**
     * Draw a polyline/polygon on a baseimage
     */

  }, {
    key: 'draw',
    value: function () {
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(line) {
        var _this3 = this;

        var type, baseImage;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                type = line.type;
                baseImage = this.image.image;
                return _context2.abrupt('return', new _promise2.default(function (resolve, reject) {
                  var points = line.coords.map(function (coord) {
                    return [_this3.xToPx(lonToX(coord[0], _this3.zoom)), _this3.yToPx(latToY(coord[1], _this3.zoom))];
                  });

                  baseImage.getBuffer(_jimp2.default.AUTO, function (err, result) {
                    if (err) reject(err);
                    if (type === 'polyline') {
                      _this3.gm(result).fill(0).stroke(line.color, line.width).drawPolyline(points).toBuffer(function (errBuf, buffer) {
                        if (errBuf) reject(err);
                        _jimp2.default.read(buffer, function (errRead, image) {
                          if (errRead) reject(err);
                          _this3.image.image = image;
                          resolve(image);
                        });
                      });
                    } else if (type === 'polygon') {
                      _this3.gm(result).fill(line.fill).stroke(line.color, line.width).drawPolygon(points).toBuffer(function (errBuf, buffer) {
                        if (errBuf) reject(err);
                        _jimp2.default.read(buffer, function (errRead, image) {
                          if (errRead) reject(err);
                          _this3.image.image = image;
                          resolve(image);
                        });
                      });
                    }
                  });
                }));

              case 3:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function draw(_x3) {
        return _ref2.apply(this, arguments);
      }

      return draw;
    }()
  }, {
    key: 'drawMarker',
    value: function drawMarker() {
      var _this4 = this;

      var baseImage = this.image.image;

      return new _promise2.default(function (resolve) {
        _this4.markers.forEach(function (marker) {
          baseImage.composite(marker.imgData, marker.position[0], marker.position[1]);
        });

        resolve(true);
      });
    }

    /**
      *   Preloading the icon image
      */

  }, {
    key: 'loadMarker',
    value: function loadMarker() {
      var _this5 = this;

      return new _promise2.default(function (resolve, reject) {
        if (!_this5.markers.length) resolve(true);

        var icons = _lodash._.uniqBy(_this5.markers.map(function (m) {
          return { file: m.img };
        }), 'file');

        var count = 1;
        icons.forEach(function (i) {
          _jimp2.default.read(i.file, function (err, tile) {
            if (err) reject(err);
            i.data = tile;
            if (count++ === icons.length) {
              // Pre loaded all icons
              _this5.markers.forEach(function (icon) {
                icon.position = [_this5.xToPx(lonToX(icon.coord[0], _this5.zoom)) - icon.offset[0], _this5.yToPx(latToY(icon.coord[1], _this5.zoom)) - icon.offset[1]];

                var imgData = _lodash._.find(icons, { file: icon.img });
                icon.set(imgData.data);
              });

              resolve(true);
            }
          });
        });
      });
    }

    /**
     *  Fetching tiles from endpoint
     */

  }, {
    key: 'getTile',
    value: function getTile(data) {
      var _this6 = this;

      return new _promise2.default(function (resolve, reject) {
        var options = {
          url: data.url,
          encoding: null,
          resolveWithFullResponse: true
        };

        if (_this6.tileRequestTimeout) options.timeout = _this6.tileRequestTimeout;

        _requestPromise2.default.get(options).then(function (res) {
          resolve({
            url: data.url,
            box: data.box,
            body: res.body
          });
        }).catch(reject);
      });
    }
  }]);
  return StaticMaps;
}();

exports.default = StaticMaps;

module.exports = StaticMaps;

Array.prototype.last = function () {
  return this[this.length - 1];
};
Array.prototype.max = function () {
  return Math.max.apply(null, this);
};
Array.prototype.min = function () {
  return Math.min.apply(null, this);
};